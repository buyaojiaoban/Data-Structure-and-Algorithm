#include <iostream>
#include <algorithm>
using namespace std;

/*
STL里sort算法用的是什么排序算法？
快速排序算法  插入排序(待排序序列的个数<=32)  堆排序(递归层数太深，转成堆排序)

快速排序的时间复杂度不是稳定的nlogn，最坏情况会变成n^2，怎么解决复杂度恶化问题？
最坏的情况就是它已经有序了，正序或者逆序
1.插入排序  2.三数取中(选择合理的基准数)

快速排序递归实现时，怎么解决递归层次过深的问题？
参考STL里面sort的堆排序方式，控制层数

递归过深会引发什么问题？
调用函数会有函数开销，函数调用次数过多，函数开销变大，导致栈内存溢出，程序挂掉

怎么控制递归深度？如果达到递归深度了还没排完序怎么办？
参考STL里面sort的堆排序方式，控制层数，没排完转成堆排序


内排序：数据都在内存上
外排序：内存小，而数据量大   只有归并排序思想可以进行外排序，磁盘上的数据排序

数据量：1024M    src.txt
内存：100M
数据量大约是内存大小的11倍
1.创建11个文件，如src01.txt,src02.txt...src11.txt
2.循环读取原始文件src.txt,每读出一个正数，轮询放入上面的11个小文件当中
=====》每一个小文件存储的正数大小，不足100M
3.分别把每一个小文件的数据全部加载到内存上，进行排序，完成后，把排序的结果写回响应的小文件当中
=====》所有小文件里面的数据是有序的
4.循环每次从src01.txt和src02.txt各读入一个数据，按照归并的思想，选出小值，写入最终的src012.txt文件中，被写入的数字，从其
对应的文件读入下一个数字，循环处理，直到两个文件的数字合并完成
5.处理src03<=>src04  等等文件依次处理完成；最终合并只剩一个文件，就是有序的文件了
*/
int main()
{
	return 0;
}