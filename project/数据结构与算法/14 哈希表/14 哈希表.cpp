#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
using namespace std;


/*
线性探测哈希表的缺陷：
1.发生哈希冲突时，一步一步找下一个空闲的位置，这个过程慢慢的趋近于O(n)时间复杂度，存储变慢了，包括查询删除都变慢了
发生哈希冲突越严重，就越靠近O(n)时间复杂度。
能否优化呢？  在线性探测里面不能优化
2.多线程环境中，线程安全问题，线性探测所用到的基于数组实现的哈希表，只能给全局的表用互斥锁来保证哈希表的原子操作，保证
线程安全！
链式哈希表，在多线程环境下，可以采用分段的锁！既保证了线程安全，又有一定的并发量，提高了效率！

线性探测有一个优化：二次探测，就是右边找一次，左边找一次，再右边

链式哈希表类似  vector<list<int>> table;
装载因子：哈希表中桶被占用一定的比例后，就要进行扩容了

哈希表增删查：无限趋近于O(1)，因为哈希冲突的存在

链式哈希表：
优化一：当链表长度大于某个指定的值的时候，把桶里面的这个链表转化成红黑树 O(logn)
优化二：链式哈希表每个桶都可以创建自己的互斥锁，不同桶中的链表操作，可以并发执行起来！

*/

// 链式哈希表
class HashTable
{
public:
	HashTable(int size = primes_[0], double loadFactor = 0.75)
		: useBucketNum_(0)
		, loadFactor_(loadFactor)
		, primeIdx_(0)
	{
		if (size != primes_[0])
		{
			for (; primeIdx_ < PRIME_SIZE; primeIdx_++)
			{
				if (primes_[primeIdx_] >= size)
					break;
			}

			if (primeIdx_ == PRIME_SIZE)
			{
				primeIdx_--;
			}
		}

		table_.resize(primes_[primeIdx_]); // resize不仅开辟空间，还会创建元素
	}

public:
	// 增加元素 不能重复插入key
	void insert(int key)
	{
		// 判断扩容
		double factor = useBucketNum_ * 1.0 / table_.size();
		cout << "factor:" << factor << endl;
		if (factor > loadFactor_) // 大于装载因子，扩容
		{
			expand();
		}

		int idx = key % table_.size();  // O(1)
		if (table_[idx].empty())
		{
			useBucketNum_++;
			table_[idx].emplace_front(key);
		}
		else
		{
			// 使用全局的::find泛型算法，而不是调用自己的成员方法find
			auto it = ::find(table_[idx].begin(), table_[idx].end(), key);  // O(n)
			if (it == table_[idx].end())
			{
				// key不存在
				table_[idx].emplace_front(key);
			}
		}
	}

	// 删除元素
	void erase(int key)
	{
		int idx = key % table_.size();  // O(1)
		// 如果链表节点过长：如果散列结果比较集中（散列函数有问题！！！）
		//                 如果散列结果比较离散，链表长度一般不会过长，因为有装载因子
		auto it = ::find(table_[idx].begin(), table_[idx].end(), key); // O(n)
		if (it != table_[idx].end())
		{
			table_[idx].erase(it);
			if (table_[idx].empty())
			{
				useBucketNum_--;
			}
		}
	}

	// 搜索元素
	bool find(int key)
	{
		int idx = key % table_.size();  // O(1)
		auto it = ::find(table_[idx].begin(), table_[idx].end(), key); // 
		return it != table_[idx].end();
	}

private:
	// 扩容函数
	void expand()
	{
		if (primeIdx_ + 1 == PRIME_SIZE)
		{
			throw "hashtable can not expand anymore!";
		}

		primeIdx_++;
		useBucketNum_ = 0;

		vector<list<int>> oldTable;
		// swap会不会效率很低？？？ 交换了两个容器的成员变量  效率很高
		/*
		如果两个容器使用的空间配置器allocator是一样的，那么直接交换两个容器的成员变量即可，效率高
		如果两个容器使用的空间配置器allocator是不一样的，那么意味着两个容器管理外部堆内存的方式不一样
		比如vec1指向的是内存池的内存，它的释放内存是内存池中释放交还给内存池；vec2的空间配置器是普通的，是堆上的内存释放
		那么交换后，vec2释放的话，就直接把内存free了，无法交还给内存池
		所以两个容器外部堆内存的方式不一样，就需要效率低的整个数据的交换
		*/
		table_.swap(oldTable);
		table_.resize(primes_[primeIdx_]);

		for (auto list : oldTable)
		{
			for (auto key : list)
			{
				int idx = key % table_.size();
				if (table_[idx].empty())
				{
					useBucketNum_++;
				}
				table_[idx].emplace_front(key);
			}
		}
	}

private:
	vector<list<int>> table_; // 哈希表的数据结构
	int useBucketNum_;        // 记录桶的个数
	double loadFactor_;       // 记录哈希表装载因子

	static const int PRIME_SIZE = 10; // 素数表的大小
	static int primes_[PRIME_SIZE];   // 素数表
	int primeIdx_; // 当前使用的素数下标
};

int HashTable::primes_[PRIME_SIZE] = { 3, 7, 23, 47, 97, 251, 443, 911, 1471, 42773 };


int main()
{
	HashTable htable;
	htable.insert(21);
	htable.insert(32);
	htable.insert(14);
	htable.insert(15);

	htable.insert(22);

	htable.insert(67);

	cout << htable.find(67) << endl;
	htable.erase(67);
	cout << htable.find(67) << endl;

	return 0;
}